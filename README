= Kiwi

Kiwi likes HTTP. Kiwi likes REST. Kiwi doesn't like it when you have to do tedious things like writing down url's to get data from your server.

== Models map to Resources

We can define a couple of models

 $m('Post', {
     resource: 'posts',
     has: {'comments':'Comment'}
   })
 
 $m('Comment'{resource: 'comments'})

So now we can say, in a controller

  $m.Post.find('all', this.publish)

or
  
  $m.Post.find(1).comments.find('all', this.publish)

or perhaps

  $m.Post.find(1).comments.find(12).destroy(this.publish)

The http requests that get fired are, respectively:
  
  http://domain.com/posts (GET)
  http://domain.com/posts/1/comments (GET)
  http://domain.com/posts/1/comments/12 (DELETE)

== Controllers publish to views

When a controller action executes a model call, all views that have subscribed to it get a copy of the data that came back from the server.

A simple controller:
  
  $c('Comments', {
    get: function(){
      var post_id = this.view.post_id
      var options = {
        limit: this.view.limit,
        offset: this.view.offset
      }
      $m.Post.find(post_id).comments.find('all', options, this.publish)
    }
  })
  
And a view

  $v('CommentsList', {
    listeners: {
      '.more_button click': 'Comments.get'
    },
    initialize_with: function(){
      this.limit = 10
      this.offset = 0
    }
    update: function(r){
      var view = this
      this.offset += 10
      $.each(r.data, function(){
        view.partials.comment.render_with(r.data).appendTo($".comment_body")
      })
    }
  })

== HTTP error codes rule

  
  
  